
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  
    <title>一张网页，要经历怎样的过程，才能抵达用户面前 | RainBow&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Xiaoyueyue">
    

    
    <meta name="description" content="说明一张网页，要经历怎样的过程，才能抵达用户面前？一位新人，要经历怎样的成长，才能站在技术之巅？ 推荐从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系！ 梳理主干流程 从浏览器接收 url 到开启网络线程 【浏览器的机制以及进程与线程之间的关系】 开启网络线程到发出一个完整的 http 请求 【dns 查询，tcp/ip 协议，五层英特网协议】 从服务器接收到请求到对应后台接收">
<meta name="keywords" content="理解计算机">
<meta property="og:type" content="article">
<meta property="og:title" content="一张网页，要经历怎样的过程，才能抵达用户面前">
<meta property="og:url" content="https://xiaoyueyue.org/2019/05/14/一张网页，要经历怎样的过程，才能抵达用户面前/index.html">
<meta property="og:site_name" content="RainBow&#39;s Blog">
<meta property="og:description" content="说明一张网页，要经历怎样的过程，才能抵达用户面前？一位新人，要经历怎样的成长，才能站在技术之巅？ 推荐从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系！ 梳理主干流程 从浏览器接收 url 到开启网络线程 【浏览器的机制以及进程与线程之间的关系】 开启网络线程到发出一个完整的 http 请求 【dns 查询，tcp/ip 协议，五层英特网协议】 从服务器接收到请求到对应后台接收">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://xiaoyueyue.org/2019/05/14/imgs/aWebPage/TaskManager.gif">
<meta property="og:image" content="https://xiaoyueyue.org/2019/05/14/imgs/aWebPage/RequestMessage1.png">
<meta property="og:image" content="https://xiaoyueyue.org/2019/05/14/imgs/aWebPage/render.png">
<meta property="og:image" content="https://xiaoyueyue.org/2019/05/14/imgs/aWebPage/htmlRender.png">
<meta property="og:image" content="https://xiaoyueyue.org/2019/05/14/imgs/aWebPage/htmlDom.png">
<meta property="og:image" content="https://xiaoyueyue.org/2019/05/14/imgs/aWebPage/CSSOM.png">
<meta property="og:image" content="https://xiaoyueyue.org/2019/05/14/imgs/aWebPage/renderTree.png">
<meta property="og:image" content="https://xiaoyueyue.org/2019/05/14/imgs/aWebPage/renderProcess.jpg">
<meta property="og:image" content="https://xiaoyueyue.org/2019/05/14/imgs/aWebPage/chromeDug.jpg">
<meta property="og:updated_time" content="2019-05-21T02:06:57.037Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一张网页，要经历怎样的过程，才能抵达用户面前">
<meta name="twitter:description" content="说明一张网页，要经历怎样的过程，才能抵达用户面前？一位新人，要经历怎样的成长，才能站在技术之巅？ 推荐从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系！ 梳理主干流程 从浏览器接收 url 到开启网络线程 【浏览器的机制以及进程与线程之间的关系】 开启网络线程到发出一个完整的 http 请求 【dns 查询，tcp/ip 协议，五层英特网协议】 从服务器接收到请求到对应后台接收">
<meta name="twitter:image" content="https://xiaoyueyue.org/2019/05/14/imgs/aWebPage/TaskManager.gif">
<meta name="twitter:creator" content="@yanyueyou">

    
    <link rel="alternative" href="/atom.xml" title="RainBow&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.jpg" alt="RainBow&#39;s Blog" title="RainBow&#39;s Blog"></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="RainBow&#39;s Blog">RainBow&#39;s Blog</a></h1>
				<h2 class="blog-motto">余则缊袍敝衣处其间，略无慕艳意。以中有足乐者，不知口体之奉不若人也！</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/todolist">TodoList</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索">
						<input type="hidden" name="q" value="site:xiaoyueyue.org">
					</form>
					
					</li>
				</ul>
			</ul></nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/14/一张网页，要经历怎样的过程，才能抵达用户面前/" title="一张网页，要经历怎样的过程，才能抵达用户面前" itemprop="url">一张网页，要经历怎样的过程，才能抵达用户面前</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xiaoyueyue" target="_blank" itemprop="author">Xiaoyueyue</a>
		
  </p><p class="article-time">
    <time datetime="2019-05-14T05:49:06.761Z" itemprop="datePublished"> 发表于 2019-05-14 13:49:06</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#说明"><span class="toc-number">1.</span> <span class="toc-text">说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#推荐"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">推荐</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#梳理主干流程"><span class="toc-number">2.</span> <span class="toc-text">梳理主干流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从浏览器接收-url-到开启网络线程"><span class="toc-number">3.</span> <span class="toc-text">从浏览器接收 url 到开启网络线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#区分进程与线程"><span class="toc-number">3.1.</span> <span class="toc-text">区分进程与线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多进程的浏览器"><span class="toc-number">3.2.</span> <span class="toc-text">多进程的浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程的浏览器内核"><span class="toc-number">3.3.</span> <span class="toc-text">多线程的浏览器内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析-url"><span class="toc-number">3.4.</span> <span class="toc-text">解析 url</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络请求都是单独的线程"><span class="toc-number">3.5.</span> <span class="toc-text">网络请求都是单独的线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#参考"><span class="toc-number">3.5.0.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开启网络线程到发出一个完整的-http-请求"><span class="toc-number">4.</span> <span class="toc-text">开启网络线程到发出一个完整的 http 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-查询得到-IP"><span class="toc-number">4.1.</span> <span class="toc-text">DNS 查询得到 IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-ip-请求"><span class="toc-number">4.2.</span> <span class="toc-text">tcp/ip 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#三次握手的步骤（抽象）"><span class="toc-number">4.2.1.</span> <span class="toc-text">三次握手的步骤（抽象）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四次挥手的步骤（抽象）"><span class="toc-number">4.2.2.</span> <span class="toc-text">四次挥手的步骤（抽象）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-ip-的并发限制"><span class="toc-number">4.2.3.</span> <span class="toc-text">tcp/ip 的并发限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-和-post-的区别"><span class="toc-number">4.2.4.</span> <span class="toc-text">get 和 post 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五层因特网协议"><span class="toc-number">4.3.</span> <span class="toc-text">五层因特网协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从服务器接收到请求到对应后台接收请求"><span class="toc-number">5.</span> <span class="toc-text">从服务器接收到请求到对应后台接收请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#负载均衡"><span class="toc-number">5.1.</span> <span class="toc-text">负载均衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后台的处理"><span class="toc-number">6.</span> <span class="toc-text">后台的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后端与前台-http-交互"><span class="toc-number">7.</span> <span class="toc-text">后端与前台 http 交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http-报文结构"><span class="toc-number">7.1.</span> <span class="toc-text">http 报文结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#通用头部"><span class="toc-number">7.1.0.1.</span> <span class="toc-text">通用头部</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#请求-响应头部"><span class="toc-number">7.1.0.2.</span> <span class="toc-text">请求/响应头部</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#请求-响应实体"><span class="toc-number">7.1.0.3.</span> <span class="toc-text">请求/响应实体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#长连接与短连接"><span class="toc-number">7.2.</span> <span class="toc-text">长连接与短连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-2-0"><span class="toc-number">7.3.</span> <span class="toc-text">http 2.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https"><span class="toc-number">7.4.</span> <span class="toc-text">https</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#参考-1"><span class="toc-number">7.4.0.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器接收到-http-数据包后的解析过程"><span class="toc-number">8.</span> <span class="toc-text">浏览器接收到 http 数据包后的解析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#流程简述"><span class="toc-number">8.1.</span> <span class="toc-text">流程简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML-解析，构建-DOM"><span class="toc-number">8.2.</span> <span class="toc-text">HTML 解析，构建 DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成-css-规则"><span class="toc-number">8.3.</span> <span class="toc-text">生成 css 规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建渲染树"><span class="toc-number">8.4.</span> <span class="toc-text">构建渲染树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染"><span class="toc-number">8.5.</span> <span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么会引起回流？"><span class="toc-number">8.5.1.</span> <span class="toc-text">什么会引起回流？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单层和复合层"><span class="toc-number">8.6.</span> <span class="toc-text">简单层和复合层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chrome-中的调试"><span class="toc-number">8.7.</span> <span class="toc-text">Chrome 中的调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源外链的下载"><span class="toc-number">8.8.</span> <span class="toc-text">资源外链的下载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#遇到外链的处理"><span class="toc-number">8.8.1.</span> <span class="toc-text">遇到外链的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遇到-CSS-样式资源"><span class="toc-number">8.8.2.</span> <span class="toc-text">遇到 CSS 样式资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遇到-JS-脚本资源"><span class="toc-number">8.8.3.</span> <span class="toc-text">遇到 JS 脚本资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遇到-img-图片类资源"><span class="toc-number">8.8.4.</span> <span class="toc-text">遇到 img 图片类资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loaded-和-domcontentloaded"><span class="toc-number">8.9.</span> <span class="toc-text">loaded 和 domcontentloaded</span></a></li></ol></li>
		
		</div>
		
		<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>一张网页，要经历怎样的过程，才能抵达用户面前？<br>一位新人，要经历怎样的成长，才能站在技术之巅？</p>
<h5 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h5><p><a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html" target="_blank" rel="noopener">从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></p>
<h2 id="梳理主干流程"><a href="#梳理主干流程" class="headerlink" title="梳理主干流程"></a>梳理主干流程</h2><ol>
<li><a href="#从浏览器接收url到开启网络线程">从浏览器接收 url 到开启网络线程</a> 【浏览器的机制以及进程与线程之间的关系】</li>
<li><a href="#开启网络线程到发出一个完整的http请求">开启网络线程到发出一个完整的 http 请求</a> 【dns 查询，tcp/ip 协议，五层英特网协议】</li>
<li><a href="#从服务器接收到请求到对应后台接收请求">从服务器接收到请求到对应后台接收请求</a> 【负载均衡，安全拦截以及后台内部处理】</li>
<li><a href="#后端与前台http交互">后端与前台 http 交互</a>【http 请求头，报文结构，响应码，编码解码】</li>
<li>单独拎出来的缓存问题，http 的缓存（这部分包括 http 缓存头部，etag，catch-control 等）</li>
<li><a href="#浏览器接收到http数据包后的解析过程">浏览器接收到 http 数据包后的解析过程</a> 【解析 html-词法分析然后生成 dom 树，解析 css 生成 css 规则树，合并成 render 树，然后 layout，painting 渲染，复合图层的合成，cpu 绘制，外链资源的处理，DOMContentLoaded 和 load】</li>
<li><a href="#css的可视化格式模型">css 的可视化格式模型</a>【元素的渲染规则，如包含块，控制框，BFC,IFC 等概念】</li>
<li><a href="#js引擎执行机制">js 引擎执行机制</a>【js 解释阶段，预处理阶段，执行阶段生成执行上下文，vo，作用域链，回收机制等】</li>
<li>其他（可以拓展的不同知识模块，如跨域，web 安全，hybrid 模式等等内容）</li>
</ol>
<h2 id="从浏览器接收-url-到开启网络线程"><a href="#从浏览器接收-url-到开启网络线程" class="headerlink" title="从浏览器接收 url 到开启网络线程"></a>从浏览器接收 url 到开启网络线程</h2><p>这一部分展开的内容是：浏览器进程/线程模型，JS 的运行机制</p>
<h3 id="区分进程与线程"><a href="#区分进程与线程" class="headerlink" title="区分进程与线程"></a>区分进程与线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 进程是一个工厂，工厂有它的独立资源</span><br><span class="line"></span><br><span class="line">- 工厂之间相互独立</span><br><span class="line"></span><br><span class="line">- 线程是工厂中的工人，多个工人协作完成任务</span><br><span class="line"></span><br><span class="line">- 工厂内有一个或多个工人</span><br><span class="line"></span><br><span class="line">- 工人之间共享空间</span><br></pre></td></tr></table></figure>
<p>完善概念</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）</span><br><span class="line"></span><br><span class="line">- 工厂之间的相互独立 -&gt; 进程之间相互独立</span><br><span class="line"></span><br><span class="line">- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务</span><br><span class="line"></span><br><span class="line">- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成</span><br><span class="line"></span><br><span class="line">- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</span><br></pre></td></tr></table></figure>
<h3 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h3><p>浏览器是多进程的，有一个主控进程以及每一个 tab 页都会新开启一个进程（某些情况下多个 tab 会合并）</p>
<p>进程可能包括主控进程，插件进程，cpu，tab 页（浏览器内核）等等</p>
<ul>
<li>Browser 进程：浏览器的主进程（负责协调、主控），只有一个</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
<li>GPU 进程：最多一个，用于 3D 绘制</li>
<li>浏览器渲染进程（内核）：默认每个 Tab 页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白 tab 会合并成一个进程）</li>
</ul>
<p>如下图：</p>
<p><img src="../imgs/aWebPage/TaskManager.gif" alt="image"></p>
<h3 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h3><p>每一个 tab 页可以看为浏览器的内核进程，这个进程是多线程的，它有几大子线程</p>
<ul>
<li>GUI 线程<ul>
<li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</li>
<li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li>
<li>注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</li>
</ul>
</li>
<li>JS 引擎线程<ul>
<li>也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）</li>
<li>JS 引擎线程负责解析 Javascript 脚本，运行代码。<br>JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序</li>
<li>同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>
</ul>
</li>
<li>事件触发线程<ul>
<li>归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）</li>
<li>当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中</li>
<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li>
<li>注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）</li>
</ul>
</li>
<li>定时器线程<ul>
<li>传说中的 setInterval 与 setTimeout 所在线程</li>
<li>浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li>
<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）</li>
<li>注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</li>
</ul>
</li>
<li>网络请求线程<ul>
<li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li>
<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>
</ul>
</li>
</ul>
<blockquote>
<p>js 引擎线程是内核进程中的一个线程，所以说 js 引擎是单线程的。</p>
</blockquote>
<h3 id="解析-url"><a href="#解析-url" class="headerlink" title="解析 url"></a>解析 url</h3><p>url 包含以下几大部分：</p>
<ul>
<li>protocol，协议头，譬如有 http，ftp 等</li>
<li>host，主机域名或 IP 地址</li>
<li>port，端口号</li>
<li>path，目录路径</li>
<li>query，即查询参数</li>
<li>fragment，即#后的 hash 值，一般用来定位到某个位置</li>
</ul>
<h3 id="网络请求都是单独的线程"><a href="#网络请求都是单独的线程" class="headerlink" title="网络请求都是单独的线程"></a>网络请求都是单独的线程</h3><p>每次网络都需要开辟单独的线程进行，譬如如果 URL 解析到 http 协议，就会新建一个网络线程去处理资源下载</p>
<p>因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源</p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul>
<li><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012925872</a></li>
</ul>
<p><strong><a href="#梳理主干流程">⬆ 回到顶部</a></strong></p>
<h2 id="开启网络线程到发出一个完整的-http-请求"><a href="#开启网络线程到发出一个完整的-http-请求" class="headerlink" title="开启网络线程到发出一个完整的 http 请求"></a>开启网络线程到发出一个完整的 http 请求</h2><p>这一部分主要内容包括：dns 查询，tcp/ip 请求构建，五层因特网协议栈等等</p>
<h3 id="DNS-查询得到-IP"><a href="#DNS-查询得到-IP" class="headerlink" title="DNS 查询得到 IP"></a>DNS 查询得到 IP</h3><p>如果输入的是域名，需要进行 dns 解析成 IP，大致流程：</p>
<ul>
<li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host</li>
<li>如果本地没有，就向 dns 域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的 IP</li>
</ul>
<p>注意，域名查询时有可能是经过了 CDN 调度器的（如果有 cdn 存储功能的话）</p>
<h3 id="tcp-ip-请求"><a href="#tcp-ip-请求" class="headerlink" title="tcp/ip 请求"></a>tcp/ip 请求</h3><p>http 的本质就是 tcp/ip 请求，需要了解 3 次握手规则建立连接以及断开连接时的四次挥手</p>
<p>tcp 将 http 长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输</p>
<h4 id="三次握手的步骤（抽象）"><a href="#三次握手的步骤（抽象）" class="headerlink" title="三次握手的步骤（抽象）"></a>三次握手的步骤（抽象）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：hello！你是server吗？</span><br><span class="line">服务器：hello！我是server，你是client吗？</span><br><span class="line">客户端：yes，我是client</span><br></pre></td></tr></table></figure>
<p>建立成功的连接后，接下来就正式传输数据，待到断开连接时，需要四次挥手（全双工???）</p>
<h4 id="四次挥手的步骤（抽象）"><a href="#四次挥手的步骤（抽象）" class="headerlink" title="四次挥手的步骤（抽象）"></a>四次挥手的步骤（抽象）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道，只能被动接受了</span><br><span class="line">被动方：收到通道关闭的消息</span><br><span class="line">被动方：那我也告诉你，我想你那边的主动通道也关闭了</span><br><span class="line">主动方：最后收到数据，之后双方无法通信</span><br></pre></td></tr></table></figure>
<h4 id="tcp-ip-的并发限制"><a href="#tcp-ip-的并发限制" class="headerlink" title="tcp/ip 的并发限制"></a>tcp/ip 的并发限制</h4><p>浏览器对同一域名下并发的 tcp 连接是有限制的（2-10 个不等）</p>
<p>而且在 http1.0 中往往一个资源下载就需要对应一个 tcp/ip 请求</p>
<p>所以针对这个瓶颈，又出现了很多的资源优化方案???</p>
<h4 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h4><p>get 和 post 虽然本质都是 tcp/ip，但两者除了 http 层面，在 tcp/ip 层面也有却别。<br>get 会产生一个 tcp 数据包，post 产生两个</p>
<ul>
<li>get 请求：浏览器会它 header 和 data 一起发出去，服务器响应 200 并返回数据</li>
<li>post 请求:浏览器会先发出 header,服务器响应 100 continue，浏览器再发送 data，服务器响应 200 并返回数据</li>
</ul>
<h3 id="五层因特网协议"><a href="#五层因特网协议" class="headerlink" title="五层因特网协议"></a>五层因特网协议</h3><p>从客户端发出 http 请求到服务器接收，中间会经过一系列的流程。</p>
<p>从应用层发送 http 请求，到传输层经过三次握手建立 tcp/ip 连接，再到网络层 ip 寻址，再到数据链路层封装成帧，最后到物理层利用物理介质传输。</p>
<p>服务器的接收就是反过来的步骤。</p>
<p>五层英特网协议内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 应用层（dns，http）dns解析ip并发送http请求</span><br><span class="line">2. 传输层（tcp，udp）建立tcp连接（三次握手）</span><br><span class="line">3. 网络层（Ip，ARP）Ip寻址</span><br><span class="line">4. 数据链路层 （PPP）封装成帧</span><br><span class="line">5. 物理层 （利用物理介质传输比特流）物理传输（传输的时候通过双绞线，电磁波等各种介质）</span><br></pre></td></tr></table></figure>
<p>当然，其实也有一个完整的 OSI 七层框架，与之相比，多了会话层、表示层。</p>
<p>OSI 七层框架：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</span><br><span class="line"></span><br><span class="line">会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</span><br></pre></td></tr></table></figure>
<p><strong><a href="#梳理主干流程">⬆ 回到顶部</a></strong></p>
<h2 id="从服务器接收到请求到对应后台接收请求"><a href="#从服务器接收到请求到对应后台接收请求" class="headerlink" title="从服务器接收到请求到对应后台接收请求"></a>从服务器接收到请求到对应后台接收请求</h2><p>服务端在接收到请求时，内部会进行很多的处理</p>
<p>这里由于不是专业的后端分析，所以只是简单的介绍下，不深入???</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>对于大型项目，由于并发访问量很大，所以往往一台服务器是吃不消的，一般会有若干台服务器组成一个集群，然后配置反向代理实现负载均衡</p>
<p>简单来说</p>
<p><strong>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了 nginx 控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的 HTTP 响应，并将它反馈给用户</strong></p>
<h2 id="后台的处理"><a href="#后台的处理" class="headerlink" title="后台的处理"></a>后台的处理</h2><p>一般后台都是部署到容器中的，所以一般为：</p>
<ul>
<li>先是容器接收到请求（如 tomocat 容器）</li>
<li>然后对应容器中的后台程序接收到请求（如 java 程序）</li>
<li>然后就是后台会有自己的统一处理，处理完成后返回响应结果</li>
</ul>
<p>概括</p>
<ul>
<li>一般的后端是有统一的验证的，如安全拦截，跨域验证</li>
<li>如果这一步不符合规则，直接返回响应的 http 报文（如拒绝请求等）</li>
<li>然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等）</li>
<li>等程序执行完毕后，会返回一个 http 响应包（一般这一步也会经过多层封装）</li>
<li>然后就是将这个包从后端发送给前端，完成交互</li>
</ul>
<p><strong><a href="#梳理主干流程">⬆ 回到顶部</a></strong></p>
<h2 id="后端与前台-http-交互"><a href="#后端与前台-http-交互" class="headerlink" title="后端与前台 http 交互"></a>后端与前台 http 交互</h2><p>前后端交互时，http 报文作为信息的载体，非常重要</p>
<h3 id="http-报文结构"><a href="#http-报文结构" class="headerlink" title="http 报文结构"></a>http 报文结构</h3><p>报文结构一般包括：通用头部，请求/响应头部，请求/响应体</p>
<h5 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h5><p>包括如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request Url: 请求的web服务器地址</span><br><span class="line"></span><br><span class="line">Request Method: 请求方式</span><br><span class="line">（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</span><br><span class="line"></span><br><span class="line">Status Code: 请求的返回状态码，如200代表成功</span><br><span class="line"></span><br><span class="line">Remote Address: 请求的远程服务器地址（会转为IP）</span><br></pre></td></tr></table></figure>
<p>譬如，在跨域拒绝时，可能是 method 为 options，状态码为 404/405 等（当然，实际上可能的组合有很多）</p>
<p>其中，Method 的话一般分为两批次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</span><br><span class="line">以及几种Additional Request Methods：PUT、DELETE、LINK、UNLINK</span><br><span class="line"></span><br><span class="line">HTTP1.1定义了八种请求方法：GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</span><br></pre></td></tr></table></figure>
<ul>
<li>HTTP 1.0 定义参考：<a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1945</a></li>
<li>HTTP 1.1 定义参考：<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616</a></li>
</ul>
<p>列举常见状态码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class="line">304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存</span><br><span class="line">400——客户端请求有错（譬如可以是安全模块拦截）</span><br><span class="line">401——请求未经授权</span><br><span class="line">403——禁止访问（譬如可以是未登录时禁止）</span><br><span class="line">404——资源未找到</span><br><span class="line">500——服务器内部错误</span><br><span class="line">503——服务不可用</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>不同范围状态码大致含义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx——指示信息，表示请求已接收，继续处理</span><br><span class="line">2xx——成功，表示请求已被成功接收、理解、接受</span><br><span class="line">3xx——重定向，要完成请求必须进行更进一步的操作</span><br><span class="line">4xx——客户端错误，请求有语法错误或请求无法实现</span><br><span class="line">5xx——服务器端错误，服务器未能实现合法的请求</span><br></pre></td></tr></table></figure>
<h5 id="请求-响应头部"><a href="#请求-响应头部" class="headerlink" title="请求/响应头部"></a>请求/响应头部</h5><p>请求和响应头部也是分析时常用到的</p>
<p>常用的请求头部（部分）：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>接收类型，表示浏览器支持的 MIME 类型（对标服务端返回的 Content-Type）</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>浏览器支持的压缩类型,如 gzip 等,超出类型不能接收</td>
</tr>
<tr>
<td>Content-Type</td>
<td>客户端发送出去实体内容的类型</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指定请求和响应遵循的缓存机制，如 no-cache</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>对应服务端的 Last-Modified，用来匹配看文件是否变动，只能精确到 1s 之内，http1.0 中</td>
</tr>
<tr>
<td>Expires</td>
<td>缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</td>
</tr>
<tr>
<td>Max-age</td>
<td>代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1 中</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>对应服务端的 ETag，用来匹配文件内容是否改变（非常精确），http1.1 中</td>
</tr>
<tr>
<td>Cookie</td>
<td>有 cookie 并且同域访问时会自动带上</td>
</tr>
<tr>
<td>Connection</td>
<td>当浏览器与服务器通信时对于长连接如何进行处理,如 keep-alive</td>
</tr>
<tr>
<td>Host</td>
<td>请求的服务器 URL</td>
</tr>
<tr>
<td>Origin</td>
<td>最初的请求是从哪里发起的（只会精确到端口）,Origin 比 Referer 更尊重隐私</td>
</tr>
<tr>
<td>Referer</td>
<td>该页面的来源 URL(适用于所有类型的请求，会精确到详细页面地址，csrf 拦截常用到这个字段)</td>
</tr>
<tr>
<td>User-Agent</td>
<td>用户客户端的一些必要信息，如 UA 头部等</td>
</tr>
</tbody>
</table>
<p>常用的响应头部（部分）：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Access-Control-Allow-Headers</td>
<td>服务器端允许的请求 Headers</td>
</tr>
<tr>
<td>Access-Control-Allow-Methods</td>
<td>服务器端允许的请求方法</td>
</tr>
<tr>
<td>Access-Control-Allow-Origin</td>
<td>服务器端允许的请求 Origin 头部（譬如为*）</td>
</tr>
<tr>
<td>Content-Type</td>
<td>服务端返回的实体内容的类型</td>
</tr>
<tr>
<td>Date</td>
<td>数据从服务器发送的时间</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>告诉浏览器或其他客户，什么环境可以安全的缓存文档</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
</tr>
<tr>
<td>Expires</td>
<td>应该在什么时候认为文档已经过期,从而不再缓存它</td>
</tr>
<tr>
<td>Max-age</td>
<td>客户端的本地资源应该缓存多少秒，开启了 Cache-Control 后有效</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置和页面关联的 cookie，服务器通过这个头部把 cookie 传给客户端</td>
</tr>
<tr>
<td>Keep-Alive</td>
<td>如果客户端有 keep-alive，服务端也会有响应（如 timeout=38）</td>
</tr>
<tr>
<td>Server</td>
<td>服务器的一些相关信息</td>
</tr>
</tbody>
</table>
<p>一般来说，请求头部和响应头部是匹配分析的。</p>
<p>譬如，请求头部的 Accept 要和响应头部的 Content-Type 匹配，否则会报错</p>
<p>譬如，跨域请求时，请求头部的 Origin 要匹配响应头部的 Access-Control-Allow-Origin，否则会报跨域错误</p>
<p>譬如，在使用缓存时，请求头部的 If-Modified-Since、If-None-Match 分别和响应头部的 Last-Modified、ETag 对应</p>
<p>还有很多的分析方法，这里不一一赘述</p>
<h5 id="请求-响应实体"><a href="#请求-响应实体" class="headerlink" title="请求/响应实体"></a>请求/响应实体</h5><p>http 请求时，除了头部，还有消息实体，一般来说</p>
<p>请求实体中会将一些需要的参数都放入进入（用于 post 请求）。</p>
<p>譬如实体中可以放参数的序列化形式（a=1&amp;b=2 这种），或者直接放表单对象（Form Data 对象，上传时可以夹杂参数以及文件），等等</p>
<p>而一般响应实体中，就是放服务端需要传给客户端的内容</p>
<p>一般现在的接口请求时，实体中就是对于的信息的 json 格式，而像页面请求这种，里面就是直接放了一个 html 字符串，然后浏览器自己解析并渲染。</p>
<p>如下图是对某请求的 http 报文结构的简要分析</p>
<p><img src="../imgs/aWebPage/RequestMessage1.png" alt="image"></p>
<h3 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h3><p>首先看 tcp/ip 层面的定义：</p>
<ul>
<li>长连接：一个 tcp/ip 连接上可以连续发送多个数据包，在 tcp 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li>
<li>短连接：通信双方有数据交互时，就建立一个 tcp 连接，数据发送完成后，则断开此 tcp 连接</li>
</ul>
<p>然后在 http 层面：</p>
<ul>
<li>http1.0 中，默认使用的是短连接，也就是说，浏览器没进行一次 http 操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li>
<li>http1.1 起，默认使用长连接，使用长连接会有这一行 Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 http 的 tcp 连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li>
</ul>
<p>注意： <strong>keep-alive 不会永远保持，它有一个持续时间，一般在服务器中配置（如 apache），另外长连接需要客户端和服务器都支持时才有效</strong></p>
<h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><p>http2.0 不是 https，它相当于是 http 的下一代规范（譬如 https 的请求可以是 http2.0 规范的）</p>
<p>http2.0 与 http1.1 的显著不同点：</p>
<ul>
<li>http1.1 中，每请求一个资源，都是需要开启一个 tcp/ip 连接的，所以对应的结果是，每一个资源对应一个 tcp/ip 请求，由于 tcp/ip 本身有并发数限制，所以当资源一多，速度就显著慢下来</li>
<li>http2.0 中，一个 tcp/ip 请求可以请求多个资源，也就是说，只要一次 tcp/ip 请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li>
</ul>
<p>所以，如果 http2.0 全面应用，很多 http1.1 中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）</p>
<p>http2.0 的一些特性：</p>
<ul>
<li>多路复用（即一个 tcp/ip 连接可以请求多个资源）</li>
<li>首部压缩（http 头部压缩，减少体积）</li>
<li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li>
<li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li>
<li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li>
</ul>
<h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>https 就是安全版本的 http，譬如一些支付等操作基本都是基于 https 的，因为 http 请求的安全系数太低了。</p>
<p>简单来看，https 与 http 的区别就是： <strong>在请求前，会建立 ssl 链接，确保接下来的通信都是加密的，无法被轻易截取分析</strong></p>
<p>一般来说，如果要将网站升级成 https，需要后端支持（后端需要申请证书等），然后 https 的开销也比 http 要大（因为需要额外建立安全链接以及加密等），所以一般来说 http2.0 配合 https 的体验更佳（因为 http2.0 更快了）</p>
<p>一般来说，主要关注的就是 SSL/TLS 的握手流程，如下（简述）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。</span><br><span class="line"></span><br><span class="line">2. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器</span><br><span class="line">（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</span><br><span class="line"></span><br><span class="line">3. 浏览器收到服务端的证书后</span><br><span class="line"></span><br><span class="line">    - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</span><br><span class="line"></span><br><span class="line">    - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。</span><br><span class="line"></span><br><span class="line">    - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`</span><br><span class="line"></span><br><span class="line">    - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。</span><br><span class="line"></span><br><span class="line">4. 服务端收到浏览器的回复</span><br><span class="line"></span><br><span class="line">    - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`</span><br><span class="line"></span><br><span class="line">    - 和浏览器相同规则生成`session key`</span><br><span class="line"></span><br><span class="line">    - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</span><br><span class="line"></span><br><span class="line">    - 使用`session key`加密一段握手消息，发送给浏览器</span><br><span class="line"></span><br><span class="line">5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，</span><br></pre></td></tr></table></figure>
<p>之后所有的 https 通信数据将由之前浏览器生成的<code>session key</code>并利用对称加密算法进行加密</p>
<h5 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h5><ul>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></li>
</ul>
<p><strong><a href="#梳理主干流程">⬆ 回到顶部</a></strong></p>
<h2 id="浏览器接收到-http-数据包后的解析过程"><a href="#浏览器接收到-http-数据包后的解析过程" class="headerlink" title="浏览器接收到 http 数据包后的解析过程"></a>浏览器接收到 http 数据包后的解析过程</h2><h3 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h3><p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 解析html，构建dom树</span><br><span class="line">2. 解析css，生成规则树</span><br><span class="line">3. 合并dom树和css规则，生成render树</span><br><span class="line">4. 布局render树（Layout/reflow），负责各元素尺寸，位置的计算</span><br><span class="line">5. 绘制render树，绘制页面像素信息</span><br><span class="line">6. 浏览器将各层的信息发送给CPU，CPU将各层合成（composite），显示到屏幕上</span><br></pre></td></tr></table></figure>
<p>如下图：<br><img src="../imgs/aWebPage/render.png" alt="image"></p>
<h3 id="HTML-解析，构建-DOM"><a href="#HTML-解析，构建-DOM" class="headerlink" title="HTML 解析，构建 DOM"></a>HTML 解析，构建 DOM</h3><p>整个渲染步骤中，HTML 解析是第一步。</p>
<p>简单的理解，这一步的流程是这样的：<strong>浏览器解析 HTML，构建 DOM 树</strong>。</p>
<p>但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。</p>
<p>解析 HTML 到构建出 DOM 当然过程可以简述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → DOM</span><br></pre></td></tr></table></figure>
<p>譬如假设有这样一个 HTML 页面：（以下部分的内容出自参考来源，修改了下格式）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器的处理如下：<br><img src="../imgs/aWebPage/htmlRender.png" alt="image"><br>列举其中的一些重点过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</span><br><span class="line"></span><br><span class="line">2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</span><br><span class="line"></span><br><span class="line">3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</span><br><span class="line"></span><br><span class="line">4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</span><br><span class="line">例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象</span><br></pre></td></tr></table></figure>
<p>最后的 DOM 树如下：<br><img src="../imgs/aWebPage/htmlDom.png" alt="image"></p>
<h3 id="生成-css-规则"><a href="#生成-css-规则" class="headerlink" title="生成 css 规则"></a>生成 css 规则</h3><p>同理，CSS 规则树的生成也是类似。简述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → CSSOM</span><br></pre></td></tr></table></figure>
<p>譬如 style.css 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body &#123; font-size: 16px &#125;</span><br><span class="line">p &#123; font-weight: bold &#125;</span><br><span class="line">span &#123; color: red &#125;</span><br><span class="line">p span &#123; display: none &#125;</span><br><span class="line">img &#123; float: right &#125;</span><br></pre></td></tr></table></figure>
<p>那么最终的 CSSOM 树就是：<br><img src="../imgs/aWebPage/CSSOM.png" alt="image"></p>
<h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>当 DOM 树和 CSSOM 都有了后，就要开始构建渲染树了</p>
<p>一般来说，渲染树和 DOM 树相对应的，但不是严格意义上的一一对应</p>
<p>因为有一些不可见的 DOM 元素不会插入到渲染树中，如 head 这种不可见的标签或者 display: none 等</p>
<p>整体来说可以看图：<br><img src="../imgs/aWebPage/renderTree.png" alt="image"></p>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>有了 render 树，接下来就是开始渲染，基本流程如下：<br><img src="../imgs/aWebPage/renderProcess.jpg" alt="image"><br>图中重要的四个步骤就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 计算CSS样式</span><br><span class="line"></span><br><span class="line">2. 构建渲染树</span><br><span class="line"></span><br><span class="line">3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性</span><br><span class="line"></span><br><span class="line">4. 绘制，将图像绘制出来</span><br></pre></td></tr></table></figure>
<p>然后，图中的线与箭头代表通过 js 动态修改了 DOM 或 CSS，导致了重新布局（Layout）或渲染（Repaint）</p>
<p>这里 Layout 和 Repaint 的概念是有区别的：</p>
<ul>
<li>Layout，也称为 Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li>
<li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li>
</ul>
<p>回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，所以优化方案中一般都包括，尽量避免回流。</p>
<h4 id="什么会引起回流？"><a href="#什么会引起回流？" class="headerlink" title="什么会引起回流？"></a>什么会引起回流？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.页面渲染初始化</span><br><span class="line"></span><br><span class="line">2.DOM结构改变，比如删除了某个节点</span><br><span class="line"></span><br><span class="line">3.render树变化，比如减少了padding</span><br><span class="line"></span><br><span class="line">4.窗口resize</span><br><span class="line"></span><br><span class="line">5.最复杂的一种：获取某些属性，引发回流，</span><br><span class="line">很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，</span><br><span class="line">但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</span><br><span class="line">    （1）offset(Top/Left/Width/Height)</span><br><span class="line">     (2) scroll(Top/Left/Width/Height)</span><br><span class="line">     (3) cilent(Top/Left/Width/Height)</span><br><span class="line">     (4) width,height</span><br><span class="line">     (5) 调用了getComputedStyle()或者IE的currentStyle</span><br></pre></td></tr></table></figure>
<p>回流一定伴随着重绘，重绘却可以单独出现</p>
<p>所以一般会有一些优化方案，如：</p>
<ul>
<li>减少逐项更改样式，最好一次性更改 style，或者将样式定义为 class 并一次性更新</li>
<li>避免循环操作 dom，创建一个 documentFragment 或 div，在它上面应用所有 DOM 操作，最后再把它添加到 window.document</li>
<li>避免多次读取 offset 等属性。无法避免则将它们缓存到变量</li>
<li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li>
</ul>
<p>注意：<strong>改变字体大小会引发回流</strong></p>
<p>再来看一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var s = document.body.style;</span><br><span class="line"></span><br><span class="line">s.padding = &quot;2px&quot;; // 回流+重绘</span><br><span class="line">s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘</span><br><span class="line">s.color = &quot;blue&quot;; // 再一次重绘</span><br><span class="line">s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘</span><br><span class="line">s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘</span><br><span class="line">// 添加node，再一次 回流+重绘</span><br><span class="line">document.body.appendChild(document.createTextNode(&apos;abc!&apos;));</span><br></pre></td></tr></table></figure>
<h3 id="简单层和复合层"><a href="#简单层和复合层" class="headerlink" title="简单层和复合层"></a>简单层和复合层</h3><h3 id="Chrome-中的调试"><a href="#Chrome-中的调试" class="headerlink" title="Chrome 中的调试"></a>Chrome 中的调试</h3><p>Chrome 的开发者工具中，Performance 中可以看到详细的渲染过程：<br><img src="../imgs/aWebPage/chromeDug.jpg" alt="image"></p>
<h3 id="资源外链的下载"><a href="#资源外链的下载" class="headerlink" title="资源外链的下载"></a>资源外链的下载</h3><p>上面介绍了 html 解析，渲染流程。但实际上，在解析 html 时，会遇到一些资源连接，此时就需要进行单独处理了</p>
<p>简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p>
<ul>
<li>CSS 样式资源</li>
<li>JS 脚本资源</li>
<li>img 图片类资源</li>
</ul>
<h4 id="遇到外链的处理"><a href="#遇到外链的处理" class="headerlink" title="遇到外链的处理"></a>遇到外链的处理</h4><p>当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1 中是每一个资源的下载都要开启一个 http 请求，对应一个 tcp/ip 链接）</p>
<h4 id="遇到-CSS-样式资源"><a href="#遇到-CSS-样式资源" class="headerlink" title="遇到 CSS 样式资源"></a>遇到 CSS 样式资源</h4><p>CSS 资源的处理有几个特点：</p>
<ul>
<li>CSS 下载时异步，不会阻塞浏览器构建 DOM 树</li>
<li>但是会阻塞渲染，也就是在构建 render 时，会等到 css 下载解析完毕后才进行（这点与浏览器优化有关，防止 css 规则不断改变，避免了重复的构建）</li>
<li>有例外，media query 声明的 CSS 是不会阻塞渲染的</li>
</ul>
<h4 id="遇到-JS-脚本资源"><a href="#遇到-JS-脚本资源" class="headerlink" title="遇到 JS 脚本资源"></a>遇到 JS 脚本资源</h4><p>JS 脚本资源的处理有几个特点：</p>
<ul>
<li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析 HTML</li>
<li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li>
<li>defer 与 async，普通的脚本是会阻塞浏览器解析的，但是可以加上 defer 或 async 属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li>
</ul>
<p>注意，defer 和 async 是有区别的： <strong>defer 是延迟执行，而 async 是异步执行。</strong></p>
<p>简单的说（不展开）：</p>
<ul>
<li>async 是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 onload 前，但不确定在 DOMContentLoaded 事件的前或后</li>
<li>defer 是延迟执行，在浏览器看起来的效果像是将脚本放在了 body 后面一样（虽然按规范应该是在 DOMContentLoaded 事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li>
</ul>
<h4 id="遇到-img-图片类资源"><a href="#遇到-img-图片类资源" class="headerlink" title="遇到 img 图片类资源"></a>遇到 img 图片类资源</h4><p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有 src 的地方</p>
<h3 id="loaded-和-domcontentloaded"><a href="#loaded-和-domcontentloaded" class="headerlink" title="loaded 和 domcontentloaded"></a>loaded 和 domcontentloaded</h3><p>简单的对比：</p>
<ul>
<li>DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片(譬如如果有 async 加载的脚本就不一定完成)</li>
<li>load 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已经加载完成了</li>
</ul>
<p><strong><a href="#梳理主干流程">⬆ 回到顶部</a></strong></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/理解计算机/">理解计算机</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://xiaoyueyue.org/2019/05/14/一张网页，要经历怎样的过程，才能抵达用户面前/" data-title="一张网页，要经历怎样的过程，才能抵达用户面前 | RainBow&#39;s Blog" data-tsina class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2019/05/21/Interview list/" title="Interview list">
  <strong>上一篇：</strong><br>
  <span>
  Interview list</span>
</a>
</div>


<div class="next">
<a href="/2019/05/14/移动端的300毫秒点击延迟和点击穿透问题/" title="移动端的300毫秒点击延迟和点击穿透问题">
 <strong>下一篇：</strong><br> 
 <span>移动端的300毫秒点击延迟和点击穿透问题
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#说明"><span class="toc-number">1.</span> <span class="toc-text">说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#推荐"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">推荐</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#梳理主干流程"><span class="toc-number">2.</span> <span class="toc-text">梳理主干流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从浏览器接收-url-到开启网络线程"><span class="toc-number">3.</span> <span class="toc-text">从浏览器接收 url 到开启网络线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#区分进程与线程"><span class="toc-number">3.1.</span> <span class="toc-text">区分进程与线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多进程的浏览器"><span class="toc-number">3.2.</span> <span class="toc-text">多进程的浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程的浏览器内核"><span class="toc-number">3.3.</span> <span class="toc-text">多线程的浏览器内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析-url"><span class="toc-number">3.4.</span> <span class="toc-text">解析 url</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络请求都是单独的线程"><span class="toc-number">3.5.</span> <span class="toc-text">网络请求都是单独的线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#参考"><span class="toc-number">3.5.0.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开启网络线程到发出一个完整的-http-请求"><span class="toc-number">4.</span> <span class="toc-text">开启网络线程到发出一个完整的 http 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-查询得到-IP"><span class="toc-number">4.1.</span> <span class="toc-text">DNS 查询得到 IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-ip-请求"><span class="toc-number">4.2.</span> <span class="toc-text">tcp/ip 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#三次握手的步骤（抽象）"><span class="toc-number">4.2.1.</span> <span class="toc-text">三次握手的步骤（抽象）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四次挥手的步骤（抽象）"><span class="toc-number">4.2.2.</span> <span class="toc-text">四次挥手的步骤（抽象）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-ip-的并发限制"><span class="toc-number">4.2.3.</span> <span class="toc-text">tcp/ip 的并发限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-和-post-的区别"><span class="toc-number">4.2.4.</span> <span class="toc-text">get 和 post 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五层因特网协议"><span class="toc-number">4.3.</span> <span class="toc-text">五层因特网协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从服务器接收到请求到对应后台接收请求"><span class="toc-number">5.</span> <span class="toc-text">从服务器接收到请求到对应后台接收请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#负载均衡"><span class="toc-number">5.1.</span> <span class="toc-text">负载均衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后台的处理"><span class="toc-number">6.</span> <span class="toc-text">后台的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后端与前台-http-交互"><span class="toc-number">7.</span> <span class="toc-text">后端与前台 http 交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http-报文结构"><span class="toc-number">7.1.</span> <span class="toc-text">http 报文结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#通用头部"><span class="toc-number">7.1.0.1.</span> <span class="toc-text">通用头部</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#请求-响应头部"><span class="toc-number">7.1.0.2.</span> <span class="toc-text">请求/响应头部</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#请求-响应实体"><span class="toc-number">7.1.0.3.</span> <span class="toc-text">请求/响应实体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#长连接与短连接"><span class="toc-number">7.2.</span> <span class="toc-text">长连接与短连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-2-0"><span class="toc-number">7.3.</span> <span class="toc-text">http 2.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https"><span class="toc-number">7.4.</span> <span class="toc-text">https</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#参考-1"><span class="toc-number">7.4.0.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器接收到-http-数据包后的解析过程"><span class="toc-number">8.</span> <span class="toc-text">浏览器接收到 http 数据包后的解析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#流程简述"><span class="toc-number">8.1.</span> <span class="toc-text">流程简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML-解析，构建-DOM"><span class="toc-number">8.2.</span> <span class="toc-text">HTML 解析，构建 DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成-css-规则"><span class="toc-number">8.3.</span> <span class="toc-text">生成 css 规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建渲染树"><span class="toc-number">8.4.</span> <span class="toc-text">构建渲染树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染"><span class="toc-number">8.5.</span> <span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么会引起回流？"><span class="toc-number">8.5.1.</span> <span class="toc-text">什么会引起回流？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单层和复合层"><span class="toc-number">8.6.</span> <span class="toc-text">简单层和复合层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chrome-中的调试"><span class="toc-number">8.7.</span> <span class="toc-text">Chrome 中的调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源外链的下载"><span class="toc-number">8.8.</span> <span class="toc-text">资源外链的下载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#遇到外链的处理"><span class="toc-number">8.8.1.</span> <span class="toc-text">遇到外链的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遇到-CSS-样式资源"><span class="toc-number">8.8.2.</span> <span class="toc-text">遇到 CSS 样式资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遇到-JS-脚本资源"><span class="toc-number">8.8.3.</span> <span class="toc-text">遇到 JS 脚本资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遇到-img-图片类资源"><span class="toc-number">8.8.4.</span> <span class="toc-text">遇到 img 图片类资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loaded-和-domcontentloaded"><span class="toc-number">8.9.</span> <span class="toc-text">loaded 和 domcontentloaded</span></a></li></ol></li>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="xiaoyueyue165" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script>
</div>



  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Javascript/" title="Javascript">Javascript<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/开发者笔记/" title="开发者笔记">开发者笔记<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/Css/" title="Css">Css<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/github/" title="github">github<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/拥抱开源/" title="拥抱开源">拥抱开源<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Interview/" title="Interview">Interview<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/React/" title="React">React<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/理解计算机/" title="理解计算机">理解计算机<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/工具集/" title="工具集">工具集<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/观点与感想/" title="观点与感想">观点与感想<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">关注博客</p>
    <ul>
        
          <li>
            
            	<a href="http://www.ruanyifeng.com/blog/archives.html" target="_blank" title="阮一峰的网络日志">阮一峰的网络日志</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.barretlee.com/entry/" target="_blank" title="小胡子哥的博客">小胡子哥的博客</a>
            
          </li>
        
    </ul>
</div>

  <div class="linkslist">
  <p class="asidetitle">关注唱吧</p>
    <ul>
        
          <li class="changba_li">
            
            <image class="changba_Avator" src="http://aliimg.changba.com/cache/photo/874670453_200_200.jpg">
            
            
            	<a class="changba_a" href="http://changba.com/u/104571671" target="_blank" title="琳琳abcdefg">琳琳abcdefg</a>
            
          </image></li>
        
          <li class="changba_li">
            
              <image class="changba_Avator" src="http://aliimg.changba.com/cache/photo/463875924_200_200.jpg">
            
            
            	<a class="changba_a" href="http://changba.com/u/193189028" target="_blank" title="Vesp3r">Vesp3r</a>
            
          </image></li>
        
          <li class="changba_li">
            
               <image class="changba_Avator" src="http://aliimg.changba.com/cache/photo/880681979_200_200.jpg">
             
            
            	<a class="changba_a" href="http://changba.com/u/21968651" target="_blank" title="大崇崇Zebra">大崇崇Zebra</a>
            
          </image></li>
        
          <li class="changba_li">
            
                  <image class="changba_Avator" src="http://aliimg.changba.com/cache/photo/448860018_200_200.jpg">
             
            
            	<a class="changba_a" href="http://changba.com/u/39302742" target="_blank" title="基督徒小越越">基督徒小越越</a>
            
          </image></li>
        
    </ul>
</div>


  


</aside>
</div>
    </div>
    <footer><div id="footer">
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m a Front-end developer. <br>
			This is my blog,and my life is brilliant.</p>
	</section>
	 
	<div class="social-font">
		
		
		<a href="https://github.com/xiaoyueyue165" target="_blank" class="icon-github" title="github"></a>
    
    
      <a href="http://changba.com/u/39302742" target="_blank" class="icon-changba" title="changba"></a>
      
		
		
		<a href="https://twitter.com/yanyueyou" target="_blank" class="icon-twitter" title="twitter"></a>
		
		
		
		
		
		
		
		<a href="mailto:xiaoyueyue165@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019
		
		<a href="/about" target="_blank" title="Xiaoyueyue">Xiaoyueyue</a>
		

		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
